--- 
title: "Analysis of pro-level competitive matches in Counter-Strike Global Offensive"
author: "Anh-Vu Nguyen, Malaika Gupta, Wael Boukhobza"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
---
```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

# Introduction

Counter-Strike Global Offensive or CSGO is a team-based video game that is among the most popular ones in the e-sport scene. 
With growing organizations and sponsors backing the players, the top teams have their own game ‘analyst’ whose task is to study the opponents and come up with the best in-game strategies.
Data generated from thousands of matches can help viewers understand the game, and shape how future teams are going to play strategically.

## Game Description

CSGO is a first-person shooter video game where two teams of 5 players compete to achieve a variety of objectives.
These two teams play as both the Terrorist (T) and Counter- Terrorist (CT) sides over the course of a professional match. On each map, teams are initially assigned to the T or CT side and then play for 15 rounds as their assigned side. Teams switch sides after the 15th round. The first team to win 16 rounds wins the match. 

A professional match consists of a collection of performances on one or more maps, where maps are standardized and selected
from a known pool of seven maps. Players must purchase armor, weapons, defuse or rescue kits, and manage their in-game economy to maximize their chance of success.

The overall aim of the game being to eliminate the other team whilst successfully completing side objectives.
Terrorist Objectives: plant bombs, take hostages, and assassinate opponents.
Counter-Terrorists Objectives: defuse bombs, rescue hostages, and assassinate opponents.

##  How can the data bring answers to the following questions?


- Data can help understand the performance of players and teams by calculating some metrics. Those metrics can be combined to create a global rating.

- Game analysts and players traditionally only watch the demo replays to study teams and player behaviors. Data can help automate this process by showing some players’ habits. 

- Developers have tried to change weapon behaviors, game economy, maps, and player movements to make the game more balanced.  Despite numerous updates since its release 10 years ago, players constantly give their feedback to make it evolve. Having a look at win rates in different situations throughout the years can help understand the updates, and shed light on potential fixes that can be made.

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Data sources

We are going to work with files generated by the game itself. They are called ‘demo’ files and were created by developers to replay matches from any point of view.

## What match to analyse?

There are thousands of pro-level matches but only the top teams are able to play in tournaments that are called *Majors*. We chose to analyse *Major* tournaments as the strategies and team plays of the top 20 teams are the most copied by other players. Additionally the consistent level of performance of higher level teams, and the controlled environment that offline tournaments allow means that is will be easier to get meaningful data as it is less likely that teams will be influenced by external factors (internet connection, different time-zone and schedule...) .


## Getting the demo files

Each match is recorded in a *demo* file generated by the game. A demo file contains all the raw data of a match, and is intended to be read by the game to replay the match. Demo files of Majors can be downloaded from the game, or from the [HLTV](https://hltv.org) website.


We used [HLTV](https://hltv.org) to download them as it can conveniently be parsed. HLTV is a site that compiles all pro-level matches. It collaborates with event organizers to display real-time statistics and scores, and also shares recorded demo files. The code we used to automatically parse the html pages are included in the github repository. The downloaded demo files resulted in a total of 82.1GB of data, and as such has not been uploaded.


<!--chapter:end:02-data.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Data transformation

## Getting readable data

We used Selenium and Beautiful Soup to parse the [HLTV](http://hltv.org) website and to download the demo files. To avoid putting too much load on the site, we downloaded the demo files over the course of a full week. This resulted in over 600 demo files.

To generate readable data from the demo files, we used a python [library](https://github.com/pnxenopoulos/csgo) (1) to parse them in JSON files, resulting in 625 successful conversions and 20GB of pre-processed data from the original 80+GB of data. [Python notebook - pre-processing](https://github.com/anhvung/csgo_pro_matches_analysis/blob/main/code/Pre-processing.ipynb). This process concerts the demo files into json files. 

The pre-processed data is still very much dirty as some files were corrupted. Also in-game technical pauses, warmup rounds, game restarts, etc,  can mess up the format and add rounds. We still managed to clean the data with the csgo python library cleaning functions.

The following Python notebook explains the data structure of a generated JSON file: [Python notebook - data structures](https://github.com/anhvung/csgo_pro_matches_analysis/blob/main/code/Understanding%20the%20data.ipynb)

To narrow down the amount of data points, we chose to merge all the matches json files into 5 json files containing information that we judged relevant for analysis : kills data, damages data, flashed data,and grenades data. To do so, we had to iterate through all the json files and all the relevant keys that we wanted to analyse.

To combine the json files and join the matches information such as score, winner and teams, we used the parsed html from [HLTV](http://hltv.org) to cross the informations. [Python notebook - combining json files](https://github.com/anhvung/csgo_pro_matches_analysis/blob/main/code/Combining%20data.ipynb). The last step allows to have consistent data across all matches and events that can later be joined, or grouped together in R.


[Lion drive link to the combined json files and parsed html](https://drive.google.com/drive/folders/1R86RveRkboHe123dH0ieMpk8U_hgZ6qH?usp=sharing) (1.5GB)

## Kills data

The kills data stored in the *ALL_kills.json* file contains information on every kill that happened such as the player positions, weapon used etc.


## Damages data

The damages data stored in the *ALL_damages.json* file contains information on every damage dealt such as the player positions, weapon used, damage dealt etc.


## Flashes data

The flashes data stored in the *ALL_flashes.json file* contains information on every flash grenade thrown.


## grenades data

The grenades data stored in the *ALL_grenades.json file* contains information on every grenades thrown that is not a flash grenade.

(1) Analyzing Counter-Strike: Global Offensive Data, Peter Xenopoulos, (2021), GitHub repository, https://github.com/pnxenopoulos/csgo

## Common data

All the previous json data have the same information on the matches (match id, event, date) and teams (team1, team2, winner).


<!--chapter:end:03-cleaning.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Missing values
```{r, include=FALSE}
source('plot_missing.R')
knitr::opts_chunk$set(warning = FALSE,
                      message = FALSE)
```

We'll have a look at the missing data. For this analysis, be chose a subset of 30 random matches for a reasonable processing time.
Of all the matches data, only the kills and damages data frames contained missing data.


## Kills data

The kills data frame contains information about each confirmed kill by any of the 10 players of both teams.
```{r , fig.width=14, fig.height=8}
data <- readRDS(file = "data/subset_kills.Rda")
plot_missing(data, Percentflag  = TRUE)
```
(Variables beginning with 'flash')

Flash grenades are thrown to temporarily blind the enemy players.
The missing data is expected: when a player is killed, it has not necessarily been flashed by a flash grenade before (patterns 1,2,3,5 in the graph below). We can see that the vast majority of kills are done without the victim being flashed. Less than 10 percent of the kills are done with the help of flash grenades (patterns 4,6 in the graph below).


(Variables beginning with 'assist')

Similarly less than 15 percent of kills are helped with assists (patterns 2,5 in the graph below). An assist occurs when a teammate deals more than 40 points of damage to a player before that player is killed. The teammate then gets the assist for dealing damages, thus helping the kill. 

(Variables beginning with 'playerTraded')

A player is traded when one of his teammates get an immediate revenge on the enemy player who got the initial kill (patterns 3,5,6 in the graph below). Again, about 15 percent of the kills are traded. A trade is important because it ensures that the other team does not get the numerical advantage.

Surprisingly, there are no complete cases the 30 sampled matches i.e there are no kills with all three previous points at the same time

```{r , fig.width=6, fig.height=6}
data <- data %>% rename(OTHER=tick)
data <- data[,c('flashThrowerSide','flashThrowerTeam','flashThrowerName','flashThrowerSteamID','assisterName','assisterTeam','assisterSide','assisterSteamID','playerTradedName','playerTradedSteamID','playerTradedTeam','OTHER')]
plot_missing(data, Percentflag  = TRUE)
```


## Damages data

The damages data frame contains information about each damage a player receives. A damage results in less health points.

```{r , fig.width=14, fig.height=8}
data <- readRDS(file = "data/subset_damages.Rda")
plot_missing(data, Percentflag  = TRUE)
```
Most damages (98 percent) are inflicted by a player (bullet or grenade damages). But about 2 percent of damages are not dealt by a player. Those are caused by the game environment: falling damage or bomb damage (no player is linked to a planted bomb). Pattern 2 shows the affected variables


```{r , fig.width=6, fig.height=6}
data <- data %>% rename(OTHER=tick)
data <- data[,c('attackerSteamID','attackerName','attackerTeam','attackerSide','attackerX','attackerY','attackerZ','attackerAreaID','attackerAreaName','attackerViewX','attackerViewY','attackerStrafe','OTHER')]
plot_missing(data, Percentflag  = TRUE)
```


<!--chapter:end:04-missing.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Results

```{r}
#This is how to load json files 
library(jsonlite)
library(tidyverse)
#pca libraries conflict with dplyr
library(conflicted)
conflict_prefer("n", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("arrange", "dplyr")
conflict_prefer("summarise", "dplyr")
conflict_prefer("summarize", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("rename", "dplyr")
grenades <- jsonlite::fromJSON("data/ALL_grenades.json", simplifyVector = TRUE)
kills <- jsonlite::fromJSON("data/ALL_kills.json", simplifyVector = TRUE)
damages <- jsonlite::fromJSON("data/ALL_damages.json", simplifyVector = TRUE)
flashes <- jsonlite::fromJSON("data/ALL_flashes.json", simplifyVector = TRUE)
```




```{r}
#This is wheree we store the final score of each match
wins <- kills %>% group_by(match_id) %>% summarise(round_tot=last(round_tot)+1,team1=last(match_team1),team2=last(match_team2),winner=last(round_won_by),looser=if_else(last(round_won_by)!=last(match_team1),last(match_team1),last(team2)))

#final score formula takes into account overtime. An overtime can last up to 6 rounds before another overtime occurs

wins <- wins %>%  mutate(final_score_winner=if_else(round_tot<31,16, 19+3*(  (round_tot-31)%/%6))) %>%  mutate(final_score_looser=round_tot-final_score_winner) %>% mutate(score_diff=(final_score_winner-final_score_looser)/round_tot)

```


## Evaluate the performance of teams and players with a new rating

We are going to see how commonly used indicators impacts the final score.

We generated standard indicators used by event organisors and sites from the datasets:

- kpr : average number of kills per round

- adr: average damage per round)

- first_kill_ratio: ratio of the time where the team or player gets the first kill (which grants a numerical advantage)

- smokes_per_round: average number of smokes thrown in a round

- assist_ratio: ratio of kills assisted by another player than dealt more than 40 points of damage

- non_traded_ratio: ratio of kills where the victim team could not get a revenge to prevent a numerical advantage

- avg_flash_duration: average time of blinded enemy players caused by flash grenades

- blinded_ratio: ratio of kills where the victim was blinded by a flash grenade

- strafing: ratio of kills where the attacker was strafing i.e. was side stepping to avoid being immobile to the opposing player

- hs_ratio: ratio of kills where the attackerclanded a shot in the enemy's head, resulting in more damage points

```{r fig.width=8}

#team stats on kills
team_kills <- kills %>% filter(attackerTeam!=victimTeam) %>%  group_by(match_id,attackerTeam) %>% summarise(kills_tot=n(),kpr=n()/last(round_tot),team=last(attackerTeam),hs_ratio= sum(isHeadshot==TRUE)/n(),blinded_ratio=sum(victimBlinded==TRUE)/n(),first_kill_ratio=sum(isFirstKill==TRUE)/last(round_tot),non_traded_ratio=sum(isTrade==FALSE)/n(),assist_ratio= sum(!is.na(assisterTeam))/last(round_tot))



#team stats on  damages
team_damages <- damages %>% filter(attackerTeam!=victimTeam) %>%  group_by(match_id,attackerTeam) %>% summarise(adr=sum(hpDamageTaken)/last(round_tot),team=last(attackerTeam),strafing=sum(attackerStrafe==TRUE)/n())

#team stat on flash 

team_flashes <- flashes %>% filter(attackerTeam!=playerTeam) %>%  group_by(match_id,attackerTeam) %>% summarise(avg_flash_duration=sum(flashDuration)/last(round_tot),team=last(attackerTeam))

#team stats for grenades
team_grenades <- grenades  %>% rename(attackerTeam=throwerTeam) %>%   group_by(match_id,attackerTeam) %>% summarise(grenades_per_round=n()/last(round_tot),team=last(attackerTeam),smokes_per_round=sum("Smoke Grenade"==grenadeType)/last(round_tot),attack_grenades_round=sum("Smoke Grenade"!=grenadeType)/last(round_tot),event=last(match_event))

#join everything
team_killsstat <- inner_join(team_kills,wins) %>% inner_join(team_damages) %>% inner_join(team_flashes) %>%  inner_join(team_grenades)  


#create y axis score difference data
team_killsstat <- team_killsstat %>% mutate(relative_score_diff=if_else(winner!=attackerTeam,-score_diff,score_diff))



library(reshape2)
library(forcats)
#melt for graph display
df.mlt <- melt(team_killsstat,  variable.name="var",id.vars=c("relative_score_diff","score_diff","match_id","attackerTeam","kills_tot","team","winner","looser","final_score_winner","final_score_looser","team1","team2","round_tot","event"))
df.mlt <- df.mlt %>% mutate(yvalue=as.double(value)) 
#add correlation tests
df.mlt <-  df.mlt %>% group_by(var) %>% 
    mutate(pvalue= cor(yvalue, relative_score_diff)) %>% ungroup() %>% mutate(label_names=paste(as.character(var),strtrim(as.character(pvalue), 5)), sep = " ", collapse = NULL) %>% mutate(label_names=fct_reorder(label_names, -pvalue))


mylabeller <- function(variable,value){
  return(cor_tests[value])
}

#facetted graph with facets ordered by correlation test

df.mlt %>% ggplot(aes(x=yvalue, y=relative_score_diff))+
  #geom_smooth(method = "lm", se = FALSE) +
  geom_point(size = .15,alpha=0.3) +
  geom_smooth(method='lm', formula = y~x, colour='red',alpha=0.5)+
  #geom_text(, aes(x = 3, y = 0, label = paste(" ",pvalue), family = "serif"), color = 'blue',  parse = TRUE)+
  facet_wrap(~label_names, scales = "free") +
  xlab("Team stat") +
  ylab("relative score diff") +
  ylim(-2, 4)+
  labs(title = "Scatter plot of the relative score difference depending on indicator values, \nwith correlation test score", x = "Indicator value",  y = "Relative score difference")+
  theme_linedraw()



```
We can see that some indicators are more correlated than others to the relative score difference (difference of the winner's and loser's scores over the sum of the scores). For instance the kpr indicator has a correlation score of 0.6 with the relative score difference and thus can be used to evaluate a player's performance. On the contrary, the strafing and hs_ratio indicators have little to do with a team's success.

A PCA analysis better helps visualize indicators that better reflects a team's chance of winning.

```{r }
#uncomment to install ggbiplot for PCA

#library(cli)
#library(devtools)

#install_github("vqv/ggbiplot")
```

```{r}
pca.variables <- c('kills_tot', 'kpr', 'hs_ratio', 'blinded_ratio', 'first_kill_ratio',
'non_traded_ratio', 'assist_ratio', 'strafing', 'adr',  'avg_flash_duration', 'grenades_per_round')

team_killsstat.pca <- prcomp(team_killsstat[,pca.variables], center = TRUE,scale. = TRUE)

#summary(team_killsstat.pca)
team_killsstat <- team_killsstat %>% mutate(won=if_else(relative_score_diff>0,TRUE,FALSE))
```

```{r pca, fig.height=8}
library(ggbiplot)
ggbiplot(team_killsstat.pca , obs.scale = 1, var.scale =1,circle=TRUE, group=team_killsstat$won,varname.adjust = 1.7, varname.size = 2.3,  alpha = 0.2)+ xlim(-4.5, 3) + 
  ylim(-3.1, 5) +
  ggtitle("PCA of team statistics in matches")  +
  theme(plot.title = element_text(hjust = 0.5))+
  labs(colour = "Match won")

```

Indicators with directions opposite to the loosing matches and closer to the correlation circle are the most interesting ones. As we can see, the PCA analysis confirms the findings with the correlation tests.



Note that there is no indicator with a strong correlation (more than 0.7) with the score difference. But combining those indicators can still lead to a better overall rating score. We are going to achieve it with a multi-variable linear regression.

```{r rating}


# new stat generation with the linear regression lm

fit <- lm(relative_score_diff ~ kpr + adr + first_kill_ratio + grenades_per_round + attack_grenades_round + smokes_per_round + assist_ratio + non_traded_ratio + avg_flash_duration, data=team_killsstat)



coef <- coefficients(fit)

#new combined rating, with the coefficients. Start at 0.
team_killsstat <- team_killsstat %>% mutate(rating=100*(coef[1]+kpr*coef[2]+adr*coef[3]+first_kill_ratio*coef[4]+grenades_per_round *coef[5]+attack_grenades_round*coef[6]+assist_ratio*coef[8]+non_traded_ratio*coef[9]+avg_flash_duration *coef[10])) %>%  mutate(rating=100*(rating-min(rating))/(max(rating)-min(rating)))

coef

```

## Teams performance

With a new combined rating, we can take a closer look at each team's performance relative to each other

```{r  teamrating , fig.height=8,  fig.width=10}
# TOP TEAMS AT EACH EVENT
#filtering
top_teams <- team_killsstat %>% group_by(team,event) %>% summarize(rating=mean(rating)) %>% filter( !is.nan(rating) ,rating!=0) 
#list of events
level_order <- c('DreamHack Winter 2013','EMS One Katowice 2014','ESL One Cologne 2014','DreamHack Winter 2014','ESL One Katowice 2015','ESL One Cologne 2015','DreamHack Open Cluj-Napoca 2015','MLG Columbus 2016','ESL One Cologne 2016','ELEAGUE Major 2017','PGL Major Krakow 2017','ELEAGUE Major 2018','FACEIT Major 2018','IEM Katowice 2019','StarLadder Major Berlin 2019')

# generate winner col to display winner of each event
top_teams <- top_teams %>% mutate(winner= (team=="Fnatic" & event=="ESL One Cologne 2015")| (team=="Team EnVyUs" & event=="DreamHack Open Cluj-Napoca 2015") |  (team=="Luminosity Gaming" & event=="MLG Columbus 2016") | (team=="SK Gaming" & event=="ESL One Cologne 2016") | (team=="Gambit Gaming" & event=="PGL Major Krakow 2017") |(team=="Cloud9" & event=="ELEAGUE Major 2018") | ((team=='Astralis')&(event %in% c("StarLadder Major Berlin 2019","FACEIT Major 2018","IEM Katowice 2019","ELEAGUE Major 2017"))))


# reordering  function inside facets
reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
  new_x <- paste(x, within, sep = sep)
  stats::reorder(new_x, by, FUN = fun)
}

# reordering  function inside facets
scale_x_reordered <- function(..., sep = "___") {
  reg <- paste0(sep, ".+$")
  ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}


ggplot(data=top_teams, aes(x=reorder_within(team,-rating,event), y=rating,fill=winner)) +
facet_wrap(~factor(event,levels=level_order), scales = "free") +
scale_x_reordered() +
ggtitle("Team ratings at each event")  +
geom_bar(stat="identity")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

As expected the winner team is consistently in the top team ratings. However sometimes, some teams get even better ratings than the winner. This is explained by the fact that some teams have a solid performance throughout the tournament, only to get eliminated in the final stage. For example, in the Eleague Major 2017 event, Virtus.Pro was eliminated by Astralis in the finals, and Faze Clan got eliminated in the quarter-finals.

## Players performance

Events and websites like HLTV generally focus on players's performance on individual events. However it would be interesting to look at a player's performance across all event. This would smooth out players that had unexpectedly good or bad performance in an event. 

```{r playerrating}
#all time player stats
player_kills <- kills %>% filter(attackerTeam!=victimTeam) %>%  group_by(match_id,attackerSteamID) %>% summarise(kills_tot=n(),kpr=n()/last(round_tot),team=last(attackerTeam),hs_percent= sum(isHeadshot==TRUE)/n(),blinded_percent=sum(attackerBlinded==TRUE)/n(),blinded_percent=sum(victimBlinded==TRUE)/n(),first_kill_percent=sum(isFirstKill==TRUE)/last(round_tot),first_kill_percent=sum(isFirstKill==TRUE)/last(round_tot),non_traded_percent=sum(isTrade==FALSE)/n(),assist_percent= sum(!is.na(assisterTeam))/last(round_tot))

#player stats on  damages
player_damages <- damages %>% filter(attackerTeam!=victimTeam) %>%  group_by(match_id,attackerSteamID) %>% summarise(adr=sum(hpDamageTaken)/last(round_tot),team=last(attackerTeam),strafing=sum(attackerStrafe==TRUE)/n())

#player stat on flash 

player_flashes <- flashes %>% filter(attackerTeam!=playerTeam) %>%  group_by(match_id,attackerSteamID) %>% summarise(avg_flash_duration=sum(flashDuration)/last(round_tot),team=last(attackerTeam))

#player stats for grenades

player_grenades <- grenades  %>% rename(attackerSteamID=throwerSteamID) %>%   group_by(match_id,attackerSteamID) %>% summarise(grenades_per_round=n()/last(round_tot),smokes_per_round=sum("Smoke Grenade"==grenadeType)/last(round_tot),attack_grenades_round=sum("Smoke Grenade"!=grenadeType)/last(round_tot),name=last(throwerName),event=last(match_event),date=last(match_date))

#join everything
playerstat <- player_kills %>% inner_join(player_damages) %>% inner_join(player_flashes) %>%  inner_join(player_grenades)  %>% mutate(rating=100*(coef[1]+kpr*coef[2]+adr*coef[3]+first_kill_percent*coef[4]+grenades_per_round *coef[5]+attack_grenades_round*coef[6]+assist_percent*coef[8]+non_traded_percent*coef[9]+avg_flash_duration *coef[10]))


playerstat <- playerstat %>% mutate(rating=100*(rating-min(rating))/(max(rating)-min(rating)))




playerstat <- playerstat %>%  filter(!is.na(rating)) %>% group_by(attackerSteamID) %>%  summarize(name=last(name),rating=mean(rating),match_played=n())

  
```
```{r topplayers}
B <- playerstat %>%  filter(match_played>10) %>% top_n(30,rating) %>% arrange(rating) %>% mutate(name = factor(name, levels = .$name))   %>% ggplot(., aes(rating, name))  +
        geom_point()+
  labs(title = "Top 30 players all time", x = "Rating",  y = "Name")

A <- playerstat  %>%  filter(match_played>10)  %>%  top_n(-30,rating) %>% arrange(rating) %>% mutate(name = factor(name, levels = .$name)) %>% ggplot(., aes(rating, name)) + 
        geom_point()+
  labs(title = "Worst 30 players of all time", x = "Rating",  y = "Name")

library(patchwork)
A+B
```
The player Autimatic has the highest rating of all, and has one win with his team Cloud9 in the Boston Major. Interestingly, Zywoo, s1mple and device are the immediate 3 highest rated players after autimatic. The fact that those three players where nominated in the top 3 players in 2019 and 2020 by the [HLTV](https://hltv.org) website means that our combined rating reflects the different ratings of other sites such as HLTV.

It is often hard to compare teams and players across events because players often change teams. One way to cross the information is to visualize the teams of a player:

```{r interactalluv}
library(parcoords)

wins <- kills %>%  filter(attackerTeam!=victimTeam) %>%  group_by(match_id,round_num) %>% summarise(map=last(map_name),T_team=last(if_else(attackerSide=="T","T","CT")))
most_played <- kills %>%  
        group_by(match_id ) %>%
        summarise(attackerSteamID=last(attackerSteamID),attackerName=last(attackerName) ) %>%
        group_by(attackerSteamID) %>% 
        dplyr::summarise(match_count= n() , name=last(attackerName))
most_played <- most_played %>% top_n(15,match_count)
names <- most_played$name
players <- kills %>% group_by(match_event,attackerSteamID)   %>%  summarise(name=last(attackerName),team=last(attackerTeam),date=last(match_date),event=last(match_event) )
players <- filter(players, name %in% names)
players <- select(players , -c(attackerSteamID , event))
col_order <- c("name",
               "team","match_event") 
players <- players[, col_order]
players %>% 
  arrange(team) %>% 
  parcoords(rownames=F,color= list(
       colorBy = "name",
       colorScale='scaleOrdinal',
       colorScheme = "schemeCategory10"),
       withD3=T,brushMode="1D-axes",reorderable = T,queue=T,alpha=0.5)
```

```{r alluvial , fig.height=6,fig.width=13}

library(easyalluvial)

#conflict with mosaic
conflict_prefer("sum", "base")
conflict_prefer("cor", "base")

names <- c("device","dupreeh","Xyp9x","Magisk","gla1ve")

players <- kills %>% group_by(match_event,attackerSteamID)   %>%  summarise(name=last(attackerName),team=last(attackerTeam),date=last(match_date) )
players <- filter(players, name %in% names)

#players <- players %>% group_by(team,name) %>% summarise(name=last(name),team=last(team),date=last(date), count = n() , event = last(match_event),attackerSteamID=last(attackerSteamID))



level_order <- c('EMS One Katowice 2014','ESL One Cologne 2014','DreamHack Winter 2014','ESL One Katowice 2015','ESL One Cologne 2015','DreamHack Open Cluj-Napoca 2015','MLG Columbus 2016','ESL One Cologne 2016','ELEAGUE Major 2017','PGL Major Krakow 2017','ELEAGUE Major 2018','FACEIT Major 2018','IEM Katowice 2019','StarLadder Major Berlin 2019')
#players <- players[match(level_order, players$match_event),]
conflict_prefer("sum", "mosaic")
players <- players[order(factor(players$match_event, levels=unique(level_order))),]

alluvial_long(players
              , key = match_event
              , value = team
              , id = attackerSteamID
              , fill = name
              , fill_right = F
              , NA_label = 'None'
              ,order_levels_key =level_order
              ,col_vector_value = c("blue","black","green","yellow","red")
              )+labs(title = "Team changes",  y ="Player", x ="Event")
```
One of the most successful teams is Astralis with 3 Major wins. A core of 3 players (dupreeh, device, and Xyp9x) have been playing together for 10 events explaining the team's consistent success.




## Use in-game data to have the competitive advantage

The game data of matches is available to everyone and pro teams always watch their opponent's previous games to come up with strategies.

However, watching games takes time. Some parts of this process can be automated. 

Even though it does not give informations such as teams reactions to specific events, 2d-density maps can give the general trends, and habits of a player of a team.

For instance, one of the hardest player to play against is s1mple, especially with the AWP weapon because of its range. Parsing the game data allows to know where players can expect s1mple to be and where he can be aiming at with his weapon.  

```{r densitymap , fig.height=8, fig.height=10}
#heatmpas



library(ggpubr)
library(jpeg)

img <- readJPEG("img/de_mirage_light.jpg")



heat_kills <- damages %>%  filter(map_name == "de_mirage" ) %>% filter(attackerSteamID==76561198034202275) %>% filter(weapon=="AWP") %>% filter(attackerSide =="CT")
# Area + contour
a <- ggplot(heat_kills, aes(x=attackerX, y=attackerY) )+
background_image(img) +
#geom_point(alpha=0.2,color="red")+
stat_density_2d(aes(fill = log10(..level..)), geom = "polygon",alpha=0.6,h=294.1)+ scale_fill_continuous(type = "viridis")+
  geom_segment(aes(xend=victimX, yend=victimY),alpha=0.2)+
  xlim(-3050, 1700)+
  ylim(-3200,1520) + theme(aspect.ratio=1) +
  labs(title = "Positions of s1mple with the AWP weapon \non the map de_mirage, with bullet trajectories\nCT positions")+
  theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank(),
      legend.position="none",
      panel.background=element_blank(),
      panel.border=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank(),
      plot.background=element_blank())

b <- ggplot(heat_kills, aes(x=victimX, y=victimY) )+
background_image(img) +
#geom_point(alpha=0.2,color="red")+
stat_density_2d(aes(fill = log10(..level..)), geom = "polygon",alpha=0.6,h=294.1)+ scale_fill_continuous(type = "viridis")+
  geom_segment(aes(xend=attackerX, yend=attackerY),alpha=0.2)+
  xlim(-3050, 1700)+
  ylim(-3200,1520) + theme(aspect.ratio=1) +
  labs(title = "Positions of the victims of s1mple hit by the AWP weapon \non the map de_mirage, with bullet trajectories\nCT positions")+
  theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank(),
      legend.position="none",
      panel.background=element_blank(),
      panel.border=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank(),
      plot.background=element_blank())

a+b
```

Knowing the habits of a player and the positions where it is dangerous to be can avoid being surprised by the enemy and helps to come up with strategies to counter the enemy team.

## Game evolution and balance

People often attribute the success and longevity of the CSGO game to its balance, meaning that both teams have an equal chance of winning. However, this is difficult to achieve as it depends on multiple factors such as the weapon characteristics and map layout.

Because the developpers have been continuously updating the maps and weapon characterstics, the probablity to win a round on the T/CT sides has changed over the years.

```{r winrates}

wins <- kills %>%  filter(attackerTeam!=victimTeam) %>%  group_by(match_id,round_num) %>%  summarise(map=last(map_name),winner=last(round_won_by),T_team=last(if_else(attackerSide=="T",attackerTeam,victimTeam)),event=last(match_event),map=last(map_name))
wins <- wins %>% mutate(win_side=if_else(winner==T_team,'T','CT'))

global_wins <- wins %>% group_by(event) %>% summarise(event=last(event),tot=n(),T_percent=100*sum(win_side=='T')/n()) %>% mutate(CT_percent=100-T_percent)


level_order <- c('DreamHack Winter 2013','EMS One Katowice 2014','ESL One Cologne 2014','DreamHack Winter 2014','ESL One Katowice 2015','ESL One Cologne 2015','DreamHack Open Cluj-Napoca 2015','MLG Columbus 2016','ESL One Cologne 2016','ELEAGUE Major 2017','PGL Major Krakow 2017','ELEAGUE Major 2018','FACEIT Major 2018','IEM Katowice 2019','StarLadder Major Berlin 2019')


library(reshape2)
gloabl_wins_melt <- melt(global_wins,  variable.name="var",id.vars=c("event","tot"))

ggplot(gloabl_wins_melt, aes(x = factor(event, level = level_order), y = value, group=var, col=var))+ 
geom_line() + geom_point()+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
labs(title = "Winrates for each event", x = "Events",  y = "Winrate (percentage)")+
labs(color='Side') 


```

The drop in the win percentage differences after 2016 can be attributed to the update of the nuke, inferno and overpass maps. Maps updates often include changes in the layout to give more advantage to a given side.

```{r mapwinrates,  fig.height=8,fig.width=8}
map_wins <- wins %>% group_by(event,map) %>% summarise(event=last(event),tot=n(),T_percent=100*sum(win_side=='T')/n()) %>% mutate(CT_percent=100-T_percent)


map_wins_melt <- melt(map_wins,  variable.name="var",id.vars=c("event","tot","map"))

ggplot(map_wins_melt, aes(x = factor(event, level = level_order), y = value, group=var, col=var))+ 
facet_wrap(~map, ncol = 2)+
geom_line() + geom_point()+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
labs(title = "Winrates for each map", x = "Events",  y = "Winrate (percentage)")+
labs(color='Side') 

```
Nuke as been removed from the official maps after Katowice 2015 and reintroduced for Cologne 2016. It was known to greatly favor the CT side, often forcing the team starting on the T side to have an impressive comeback after switching sides on the half time.
But after the nuke map update the balance greatly improved.

Note that the map pool changes for every event. The latest map being introduced is vertigo. Because it is a new map, it is not as balanced as the other ones. 


Weapons also impact the game balance.

```{r weaponusage , fig.height=10,fig.width=8}
level_order <- c('DreamHack Winter 2013','EMS One Katowice 2014','ESL One Cologne 2014','DreamHack Winter 2014','ESL One Katowice 2015','ESL One Cologne 2015','DreamHack Open Cluj-Napoca 2015','MLG Columbus 2016','ESL One Cologne 2016','ELEAGUE Major 2017','PGL Major Krakow 2017','ELEAGUE Major 2018','FACEIT Major 2018','IEM Katowice 2019','StarLadder Major Berlin 2019')


weapon_usage <- damages %>% group_by(match_id,attackerSteamID,weapon,round_num) %>% summarize(weapon=last(weapon),date=last(match_date),event=last(match_event),side=last(attackerSide),name=last(attackerName))


weapon_usage <- weapon_usage %>% group_by(event,weapon) %>% summarize(weapon=last(weapon),weapon_usage=n(),date=last(date),event=last(event),side=last(side))
#tot_count <- weapon_usage %>%  group_by(event) %>% summarize(tot_usage=sum(weapon_usage))
tot_count <- weapon_usage %>%  group_by(event) %>% summarize(tot_usage=sum(weapon_usage))
weapon_usage <- weapon_usage %>% inner_join(tot_count) %>%  mutate(weapon_percent=weapon_usage/tot_usage)


weapon_list <- c("UMP-45",'MAC-10','MP7','MP9','P90')
a <-  ggplot(weapon_usage %>% filter( (weapon %in% weapon_list)), aes(x = factor(event, level = level_order), y = weapon_percent, group=weapon, col=weapon))+ 
geom_line() + geom_point()+ theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
        labs(title = "Weapon usage\nsmg category",  y ="Weapon usage(%)")

weapon_list <- c("CZ75 Auto",'Desert Eagle','Five-SeveN','p250','Tec-9')
b <- ggplot(weapon_usage %>% filter( (weapon %in% weapon_list)), aes(x = factor(event, level = level_order), y = weapon_percent, group=weapon, col=weapon))+ 
geom_line() + geom_point()+ theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
  labs(title = "Pistol category",  y ="Weapon usage(%)")

weapon_list <- c("AK-47",'SG 553','AUG','M4A4','M4A1')
c <- ggplot(weapon_usage %>% filter( (weapon %in% weapon_list)), aes(x = factor(event, level = level_order), y = weapon_percent, group=weapon, col=weapon))+ 
geom_line() + geom_point()+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  labs(title = "Rifle category",  y ="Weapon usage(%)",x="Events")




(a/b/c)



```

When the developers change a weapon's characteristic such as damage output, it can lead to a drop or spike in popularity.

For example, in 2017 developers tried to increase the usage of smg type weapons by increasing their damage output. As a result, the ump was often used by teams when they could not get a rifle. But complains from pro players meant that the update was reverted.

The same can be said for the cz-75 in 2018. Also, the p250, five-seven and tec-9 had their damage and accuracy decreased over the years and resulted in a drop in usages by the pro players.

Finally, it happens that players discover that a weapon can be very effective, even without its characteristics being changed. This is what happened in 2019 when players started to use the AUG and the SG 553 weapons for their good accuracy at long range. 




<!--chapter:end:05-results.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Interactive component



## Explaination 

The interactive component allows the user to study the positions of a team on a specitic map. Positions are split in *CT* and *T* positions as both sides face each other. Hovering over points shows attacker, victim and weapon information.

## Interactive maps


<a href="06-heatmap.html"><b>Click to see the interactive component in full size</b></a>




```{r, echo=FALSE}
htmltools::includeHTML("docs/06-heatmap.html")
```

<!--chapter:end:06-interactive.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Conclusion


<!--chapter:end:07-conclusion.Rmd-->

